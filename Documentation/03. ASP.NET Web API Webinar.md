![Logo](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/developer_media_logo.jpg)

# ASP.NET Web API - Documentation

##### Table of Contents  
1. [Introduction](#introduction)
2. [Preparing with a simple model](#model)
3. [Requesting data with jQuery](#jQuery)

6. [More](#more)


<a name="introduction"/>
## 1. Introduction

The last two Webinars concentrated on client-side JavaScript. Let's review another important part of a modern website: the communication between client and server. It should be lightweight (no SOAP) and standard conform (REStful). On client-side we are already well equipped with jQuery and Knockout. On the server side we have an ASP.NET MVC 4 website that serves more or less static HTML content. Of course, we could use ASP.NET MVC to send and receive JSON data, but Microsoft offers a dedicated API that offers additional features such as a cleaner code, content-negotiation or improved routing. The bad news for WCF-enthusiasts: all WCF-bits were removed. The god news for all ASP.NET guys: many ASP.NET MVC knowledge can be still required.    

 
<a name="model"/>
## 2. Preparing a simple model

We will use again a very simple model. It is a single C# class that represents a sticky post. It can have categories, which are just plain strings for simplicity.  

```csharp
public class Note
{
    public Note()
    {
        Categories = new List<string>();
    }

    public int Id { get; set; }

    public string Title { get; set; }

    public string Message { get; set; }

    public DateTime Added { get; set; }

    public IEnumerable<string> Categories { get; set; }
}
```

We will use this model to show a editable list of sticky notes:

![Screenshot](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/03_1_screenshot.png) 

Letâ€™s assume that we have created a new project from the installed Visual Studio 2012 templates. (ASP.NET MVC 4 Web Application > Web API) This template has all the required Nuget packages included, ships with some tweaks in the web.config and contains the required registration of a default Web API route. These steps can be added to any existing ASP.NET project, too. The only hard dependency is the targeted version of the .NET framework (version 4.0 or later).
> In contrast to other technologies (e.g. the WCF - Windows Communication Foundation) the ASP.NET Web API is built with respect to the **"Convention Over Configuration"** principle.

Without any further configuration-ceremony we can just add a class to the project to offer one or more notes as a resource. (a resource is a source of specific information in a RESTful architecture) By convention the class must inherit from System.Web.Http.ApiController and must end with the word "Controller". This naming convention is well-known in the ASP.NET MVC world, too. The file can be located everywhere in the project (it's loaded via reflection), but it is a good start to add it in the namespace & folder "Controllers". 

```csharp
public class NoteController : ApiController
{
}
```

This resource will be available under to URL **"/api/note"** as specified in the default route:

```csharp
config.Routes.MapHttpRoute(
    name: "DefaultApi",
    routeTemplate: "api/{controller}/{id}",
    defaults: new { id = RouteParameter.Optional }
);
```

The conventions continue with the naming of the methods. To respond to a HTTP GET request, the method should start with the prefix "Get". Since the id was marked as optional, we can add two methods: one for a request without an ID in the URL and one for the optional id (eg. **"api/note/222"**).

```csharp
public class NoteController : ApiController
{
    public IEnumerable<Note> GetAll()
    {
        return NoteRepository.ReadAll();
    }

    public Note Get(int id)
    {
        return NoteRepository.Read(id);
    }
}
``` 
      
The exact method name does not matter, just the prefix and the parameter signature is important. 

<a name="jQuery"/>
## 3. Requesting data with jQuery

The ASP.NET Web API was clearly made for serving AJAX driven websites. A very easy-to use [AJAX api is provided by jQuery](http://api.jquery.com/category/ajax/). Our simple Web API can be consumed with the following lines of code:  

```javascript
$.getJSON('/api/note').done(function (xhr) {
  console.log("AJAX Result: ", xhr)
});
```

The Web API will respond with [JSON-formatted data](http://www.json.org/) so that jQuery can automatically convert the data to a JavaScript object. To get the note with the number 2, we just have to change the URL:

```javascript
$.getJSON('/api/note/2').done(function (xhr) {
  console.log("AJAX Result: ", xhr)
});
```

We are working with normal HTTP requests - just like any other website. It's time to review the response directly in the browser. Let's open the Web API URL directly in the browser! (eg. [http://localhost/api/note/2](http://localhost:1340/api/note/2)) The result might be surprising. Instead of JSON-formatted data we are receiving some unexpected XML! We should debug that issue. 

![Screenshot](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/03_2_xml.png) 

<a name="fiddler"/>
## 4. Debugging with fiddler

[Fiddler](http://fiddler2.com/) is a web debugging proxy which logs all HTTP traffic between your computer and the internet (or your local server). Today, all modern browsers offer a network debugger, too (press F12 key). But Fiddler is still a very convenient tool when it comes to manipulate the requests or responses.

This is the request we created, while surfing the URL directly with the browser:

![Screenshot](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/03_3_fiddler_header_xml.png)

In comparison to that, this is the request made by the jQuery AJAX call:

![Screenshot](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/03_4_fiddler_header_json.png)

You will notice, that we have send two different Accept-Headers. When surfing around the web, we probably want the see a HTML-formatted document. That's why we are sending a "text/html" header. But according to the browser, it would be also ok to get a document in any XML-format. This "application/xml" **media type** is recognized and build-in to the ASP.NET Web API. As requested, the Web API responds with a XML-formatted document. This mechanism is called **[content negotiation](http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html)**.

We can prove that behavior by manipulation the first request with Fiddler. Switch to the "Composer" tab and drag&drop the first request to that tab. Change the accept header to "Accept: application/xml" as shown in the following screenshot and start a new request by clicking on execute.

![Screenshot](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/03_5_fiddler_header_composer.png)

It also possible to manipulate any response to quickly confirm the correct behavior of the client. For that Fiddler offers a set of "[QuickExec](http://fiddler2.com/documentation/KnowledgeBase/QuickExec)" commands. Just type `bpv GET` to stop on every GET request. 

![Screenshot](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/03_6_fiddler_breakpoint.png)

On the next GET request you will see the following screen. Click on the request in the list, go to the inspector and let the call go though by clicking the yellow <span style="color:red; background-color: yellow">"Break on Response" </span>button. We are now free to change virtually anything of that response. For example, change the status code from "HTTP/1.1 200 OK" to "HTTP/1.1 500 Something went really wrong!" and hit "Run to Completion". As expected, the browser will receive an error:

![Screenshot](https://raw.github.com/JohannesHoppe/DeveloperMediaDemo/master/Documentation/images/03_7_fiddler_simulated_error.png)


By just entering `bpv` the breakpoint is removed again. 


<a name="more"/>
## 6. More 

This was a very rough overview. There are several details to discover.
You should start by downloading the sources of the Single Page app.

&nbsp;&nbsp; __[&raquo; Download Demo-Code (.zip)](http://dl.bintray.com/johanneshoppe/DeveloperMediaDemo/DeveloperMediaWebinar_Knockout_Teil2_SinglePage.zip?direct)__


<hr>
_&copy; 2013, Johannes Hoppe_